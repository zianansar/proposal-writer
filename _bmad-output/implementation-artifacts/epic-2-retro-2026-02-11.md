# Epic 2 Retrospective — Security & Encryption

**Project:** Upwork Research Agent
**Epic:** Epic 2 — Security & Encryption
**Retrospective Date:** 2026-02-11
**Facilitator:** Bob (Scrum Master)
**Participants:** Alice (Product Owner), Charlie (Senior Dev), Dana (QA Engineer), Elena (Junior Dev), Zian (Project Lead)

---

## Executive Summary

Epic 2 delivered **100% completion** with all 10 stories marked done. The epic established the complete security and encryption foundation: SQLCipher database encryption (AES-256), Argon2id passphrase key derivation, OS keychain integration for API keys, passphrase recovery options, and encrypted database access on restart. The team overcame a mid-epic story split (2-7 → 2-7a/2-7b), caught critical security bugs through adversarial code review, and resolved long-standing technical debt from Epic 1.

**Key Metrics:**
- **Stories Completed:** 10/10 (100%) — includes Story 2-7 split into 2-7a + 2-7b
- **Test Coverage:** 194+ Rust tests, 245+ frontend tests passing
- **Code Reviews Conducted:** 10 formal reviews (2-3 rounds on complex stories)
- **Critical Issues Found in Review:** ~10 critical/high security and integration bugs caught before merge
- **Technical Debt Items:** 6 deferred items documented
- **Blockers:** 0 unresolved
- **Production Incidents:** 0 (development phase)

**Timeline:**
- Epic started: February 5, 2026
- Epic completed: February 11, 2026
- Duration: ~7 days (interleaved with Epics 3-6, 8; accelerated by AI-assisted development)

---

## What Went Well (Successes)

### 1. Complete Security Stack Delivered — All Architecture Requirements Met

**Evidence:** All 10 stories implemented AR-2 (SQLCipher 4.10), AR-3 (Argon2id key derivation), AR-7 (encryption at rest), AR-17 (OS keychain for API keys).

**Impact:**
- AES-256 database encryption protects all user data at rest (NFR-7)
- API keys moved from plaintext config to OS Credential Manager/Keychain (NFR-10)
- Passphrase recovery options prevent permanent data loss
- Migration safety protocol (backup → migrate → verify → recover) provides defense-in-depth

**Lesson:** Architecture decisions made during planning (ATTACH DATABASE, Argon2id parameters, migration safety protocol) were validated by implementation without requiring changes.

### 2. ATTACH DATABASE Atomic Migration Validated Architecture Decision

**Evidence:** Story 2-3 implemented the ATTACH DATABASE approach from architecture.md for SQLite → SQLCipher migration.

**Impact:**
- Single atomic transaction — no partial migration state possible
- ~10x faster than row-by-row copy approach
- Worked on both Windows and macOS without platform-specific code
- Backup-restore fallback (Story 2-5) provided additional safety net

**Lesson:** Investing time in architecture decisions pays dividends — the ATTACH DATABASE approach was riskier than row-by-row but the architecture team's analysis was correct.

### 3. Code Review Caught Every Critical Security/Integration Bug

**Evidence:** All 10 stories had adversarial code reviews. Critical findings included:
- Story 2-1: PassphraseEntry not integrated into App.tsx (CRITICAL)
- Story 2-6: `migrate_api_key_to_keychain()` never called — AC-2 not implemented (HIGH)
- Story 2-7b: `unlock_with_recovery_key` called `database.get()` on locked DB (CRITICAL)
- Story 2-9: XOR encryption for recovery keys — fundamentally insecure (HIGH)
- Story 2-7b: Recovery files lacked restrictive permissions (MEDIUM)

**Impact:**
- Zero security vulnerabilities shipped
- All integration gaps caught before merge
- Multi-round reviews (2-7a, 2-7b, 2-9) resolved progressively harder issues

**Lesson:** Adversarial code review with fresh context remains the single most effective quality gate. Security-sensitive stories benefit from 2+ review rounds.

### 4. OnceLock Pattern Innovation Improved on Original Design

**Evidence:** Story 2-7b replaced the planned `Mutex<Option<Database>>` with `OnceLock<Database>` via an `AppDatabase` wrapper.

**Impact:**
- Zero-cost reads after initialization (no locking overhead on every command invocation)
- Write-once semantics prevent accidental re-initialization
- Cleaner API: `database.get()?` returns clear error when database not yet unlocked
- Required updating ~53 Tauri commands but resulted in architecturally superior design

**Lesson:** Implementation sometimes discovers better patterns than planning anticipated. The team correctly chose the better approach despite the migration cost.

### 5. Epic 1 Technical Debt (Log Level Initialization) Finally Resolved

**Evidence:** Story 2-1 Task 8 implemented the config.json external configuration approach, resolving the chicken-and-egg problem (logging needs DB for settings, but DB errors need logging) that was deferred twice in Epic 1.

**Impact:**
- Log level now read from config.json before database initialization
- Belt-and-suspenders approach: config.json + database settings kept in sync
- Eliminated the most prominent deferred debt item from Epic 1

**Lesson:** Deferred debt items need a forcing function. Story 2-1 was the right place to resolve this because it already touched the initialization sequence.

### 6. Migration Safety Protocol Worked End-to-End

**Evidence:** The 4-story migration sequence (2-2 backup → 2-3 migrate → 2-4 verify → 2-5 recover) implemented the Round 4 Red Team safety protocol exactly as designed.

**Impact:**
- Pre-migration backup is automatic and verified before migration proceeds
- User gets verification screen with row counts to confirm data integrity
- Failure recovery restores from backup atomically
- User chooses whether to delete or keep unencrypted database

**Lesson:** Multi-story safety protocols work when dependencies are clearly defined and each story respects the handoff contract.

---

## What Didn't Go Well (Challenges)

### 1. Story 2-7 Split — Scope Underestimation for Cross-Cutting State Changes

**Evidence:** Story 2-7 (Encrypted Database Access on Restart) was split into 2-7a (backend) and 2-7b (frontend) after code review on Feb 5. The state refactoring prerequisite (changing Database to AppDatabase with OnceLock) touched ~53 Tauri commands.

**Impact:**
- Story 2-7a completed Feb 5 but 2-7b didn't finish until Feb 11 (6-day gap)
- State refactoring was a cross-cutting architectural change, not a frontend task
- Original story underestimated scope: "update lib.rs" became "refactor entire command surface"

**Root Cause:** Stories that change shared state management patterns are architectural changes disguised as feature stories. They need spike/analysis before commitment.

**Action Required:** Flag stories involving shared state changes as "needs architectural spike" during sprint planning.

### 2. Integration Gaps in 30% of Stories — Components Built But Not Wired In

**Evidence:**
- Story 2-1: PassphraseEntry component created but not rendered in App.tsx (CRITICAL)
- Story 2-6: `migrate_api_key_to_keychain()` function created but never called (HIGH)
- Story 2-7b: `unlock_with_recovery_key` called `database.get()` which errors when DB locked (CRITICAL)

**Impact:**
- Features technically "implemented" but non-functional until code review caught the gaps
- Pattern suggests dev agents focus on building components without verifying end-to-end flow
- 3 out of 10 stories had this pattern (30%)

**Root Cause:** No explicit "integration verification" task in story templates. Dev workflow ends at "tests pass" without checking "feature works in app context."

**Action Required:** Add mandatory "Integration Verification" checklist to every story (component rendered, command invoked, end-to-end flow tested).

### 3. Security Implementation Errors Requiring Fix

**Evidence:**
- Story 2-9: Initial implementation used XOR encryption for recovery keys — cryptographically insecure
- Story 2-7b: Recovery files (.recovery_hash, .recovery_wrapped_key) written with default OS permissions — sensitive data readable by same-user processes
- Story 2-1: Memory zeroing (zeroize crate) and secure passphrase transport deferred

**Impact:**
- XOR encryption would have been a real vulnerability if shipped
- File permissions gap less severe (same-user access) but violated defense-in-depth
- Deferred security items accumulate without resolution mechanism

**Root Cause:** Security-sensitive code requires deeper domain expertise than typical feature work. XOR encryption "looks like" encryption but isn't.

**Action Required:** Mandate 2-round minimum code review for security-tagged stories.

### 4. Poor Follow-Through on Epic 1 Retro Action Items (1/5 Completed)

**Evidence:** From Epic 1 retro tracking (updated Feb 7):
- Action 1 (Manual Test Checklist): Partial — not standardized
- Action 2 (Async Testing Guidelines): Not started
- Action 3 (Performance Regression in CI): Not started
- Action 4 (Story Status SOP): Partial
- Action 5 (Epic-Level Debt Summary): Done

**Impact:**
- Knowledge captured in retro but not actioned
- Async testing guidelines still missing (though less critical for Epic 2's sync crypto work)
- No CI pipeline for performance regression
- Story task tracking inconsistent (Story 2-3 all tasks unchecked despite completion)

**Root Cause:** Retro action items assigned but no accountability mechanism. No one tracked whether commitments were followed through.

**Action Required:** Track retro action items in sprint-status.yaml with weekly status check.

### 5. Backend Test Infrastructure Gap (Tauri Test Harness)

**Evidence:** Stories 2-8 and 2-9 deferred backend command-level unit tests because no Tauri test harness exists. Manual NFR validation (startup time, UI responsiveness) done via code review rather than measurement.

**Impact:**
- Backend commands tested only through integration tests (if at all)
- NFR compliance based on code analysis, not measurement
- Test coverage gap grows with each epic

**Root Cause:** Tauri v2 command testing requires app context (State, AppHandle) that's difficult to mock in unit tests.

**Action Required:** Invest in Tauri test harness before post-MVP development.

### 6. Build Environment Friction (Windows/macOS OpenSSL)

**Evidence:**
- Story 2-1: Windows SQLCipher build required vcpkg + OpenSSL 3.6.1 configuration
- Story 2-9: Had to comment out Windows-specific vcpkg config in .cargo/config.toml for macOS dev
- Cargo configuration toggling between platforms introduced friction

**Root Cause:** SQLCipher with vendored OpenSSL has platform-specific build requirements that aren't handled by a unified build configuration.

**Action Required:** Consolidate build configuration for cross-platform development (cfg-based .cargo/config.toml or build script).

---

## Key Insights & Lessons Learned

### 1. Integration Verification Must Be Explicit — "Built" ≠ "Shipped"

**Insight:** Building a component and wiring it into the application are two distinct tasks. Dev agents consistently complete the first but miss the second. 30% of stories had this gap.

**Evidence:** Stories 2-1, 2-6, 2-7b all had components/functions that were implemented but never integrated into the app flow.

**Application:** Add "Integration Verification Checklist" to every story:
- [ ] Component imported and rendered in correct parent (App.tsx or page component)
- [ ] Tauri command registered in invoke_handler
- [ ] End-to-end flow manually verified (or integration test covers it)
- [ ] State transitions work correctly (app state machine updated)

### 2. Security Code Needs Domain Expertise, Not Just Code Skills

**Insight:** Cryptographic implementations require specific domain knowledge. XOR "looks like" encryption to a general developer but is trivially breakable. This isn't a code quality issue — it's a knowledge gap.

**Evidence:** Story 2-9 initially implemented XOR encryption for recovery keys. Code was clean, tested, and well-documented — but fundamentally insecure.

**Application:**
- Security stories should reference specific algorithms (AES-256-GCM, Argon2id, PBKDF2) in acceptance criteria
- Code review for security stories should specifically validate algorithm choice, not just implementation
- Consider adding security checklist: "Is the crypto algorithm appropriate for the threat model?"

### 3. Cross-Cutting State Changes Are Architectural, Not Feature Work

**Insight:** Changing from eager Database initialization to deferred AppDatabase with OnceLock touched every command in the application. This is not a "frontend" or "backend" task — it's an architectural refactoring that happens to enable a feature.

**Evidence:** Story 2-7 split into 2-7a/2-7b. The state refactoring prerequisite updated ~53 commands and changed the application's initialization model.

**Application:**
- During sprint planning, flag stories that change shared state management patterns
- Require architectural spike before committing to scope
- Consider making state refactoring its own story with clear scope boundaries

### 4. Retro Commitments Need Forcing Functions, Not Just Documentation

**Insight:** Writing action items in a retro document doesn't make them happen. Only 1/5 Epic 1 action items completed. The team captured knowledge but didn't act on it.

**Evidence:** Async testing guidelines never created. CI pipeline never built. Manual test checklists partially adopted.

**Application:**
- Add retro action items to sprint-status.yaml as trackable items
- Review action item status at each standup or sprint start
- If an action item isn't done after 2 epics, either do it or explicitly remove it with justification

### 5. Multi-Round Code Review Is Worth the Investment for Complex Stories

**Insight:** Stories 2-7a, 2-7b, and 2-9 all needed 2 rounds of code review. Each round found distinct categories of issues — Round 1 caught integration and security bugs, Round 2 caught edge cases and polish items.

**Evidence:**
- Story 2-7b R1: 2 CRITICAL (recovery unlock broken), 3 MEDIUM → R2: 3 MEDIUM, 3 LOW
- Story 2-9 R1: 4 HIGH, 4 MEDIUM, 2 LOW → R2: 4 MEDIUM, 3 LOW

**Application:** Multi-round review should be mandatory for stories that are security-sensitive, touch shared state, or have >5 files changed.

---

## Technical Debt Identified

### HIGH Priority

1. **DB re-key for recovery key flow (Story 2-9, AC-6 incomplete)**
   - **Issue:** Recovery key can unlock the database but cannot set a new passphrase and re-encrypt. AC-6 partially met.
   - **Impact:** Users who forget passphrase can access data via recovery key but can't re-secure it with a new passphrase
   - **Location:** keychain/recovery.rs, lib.rs (unlock_with_recovery_key, set_new_passphrase_after_recovery)

### MEDIUM Priority

2. **Memory zeroing for passphrase handling (Story 2-1, deferred)**
   - **Issue:** Passphrase remains in memory as plain String; no zeroize crate integration
   - **Impact:** Defense-in-depth gap; passphrase could be read from memory dump
   - **Location:** passphrase/mod.rs, lib.rs

3. **Secure passphrase transport to backend (Story 2-1, deferred)**
   - **Issue:** Passphrase sent as plain String in Tauri command IPC
   - **Impact:** Passphrase visible in process memory during IPC
   - **Location:** lib.rs:424

4. **Tauri test harness for backend command testing**
   - **Issue:** No way to unit test Tauri commands with State/AppHandle; tests consistently deferred
   - **Impact:** Backend command behavior validated only through integration tests
   - **Affects:** Stories 2-8, 2-9, and future stories

5. **Fix 6 pre-existing test failures in PreMigrationBackup.test.tsx**
   - **Issue:** 6 tests failing in PreMigrationBackup component tests
   - **Impact:** Erodes confidence in test suite; may mask new regressions
   - **Location:** src/components/PreMigrationBackup.test.tsx

### LOW Priority

6. **500ms timing heuristic for passphrase-required event (Story 2-7b)**
   - **Issue:** Backend emits `passphrase-required` event with 500ms delay assuming frontend is mounted
   - **Impact:** Race condition possible if frontend takes longer to mount
   - **Location:** lib.rs:2765

7. **SQLCipher PRAGMA construction uses format! (Story 2-1)**
   - **Issue:** `format!` used to construct PRAGMA key command instead of parameterized approach
   - **Impact:** Low risk (hex-encoded key) but not ideal pattern
   - **Location:** db/mod.rs:55

---

## Previous Retrospective Follow-Through Analysis

### Epic 1 Action Items Status

| # | Action Item | Owner | Status | Evidence |
|---|------------|-------|--------|----------|
| 1 | Manual Test Checklist in Story Template | Bob (SM) | Partial | Some stories had checklists; not standardized |
| 2 | Async Testing Guidelines Document | Charlie | Not Done | No document created |
| 3 | Performance Regression Testing in CI | Charlie | Not Done | No CI pipeline |
| 4 | Story Status Lifecycle SOP | Bob (SM) | Partial | sprint-status.yaml tracks states but task checkboxes inconsistent |
| 5 | Epic-Level Deferred Debt Summary | Bob (SM) | Done | Debt tracked in story files |

**Follow-Through Rate:** 1/5 completed (20%), 2/5 partial, 2/5 not addressed

### Epic 1 Critical Path Preparation Tasks Status

| # | Task | Status | Evidence |
|---|------|--------|----------|
| 1 | Log Level Initialization Fix Design | Done | Story 2-1 Task 8 implemented config.json solution |
| 2 | Backup/Restore Validation | Done | Story 2-2 completed |
| 3 | SQLCipher Windows Testing | Done | Stories 2-3, 2-4 passed |
| 4 | Async Testing Guidelines | Not Done | No document created |

**Preparation Task Completion:** 3/4 completed (75%)

### Lessons Applied Assessment

| Epic 1 Lesson | Applied in Epic 2? | Evidence |
|--------------|-------------------|----------|
| Code review catches critical issues | Yes | All 10 stories reviewed; critical security bugs caught |
| Initialization order needs planning | Yes | Story 2-1 resolved log level initialization |
| Async testing needs patterns | No | No guidelines created; less relevant for crypto work |
| Manual tests need checklists | Partial | Some stories had validation; not standardized |
| Debt needs epic visibility | Yes | Debt documented in story files |

---

## Action Items for Process Improvement

### Action 1: Add Integration Verification Checklist to Every Story

**Owner:** Scrum Master (Bob)
**Deadline:** Before post-MVP epic starts
**Success Criteria:** Story template includes mandatory "Integration Verification" section with:
- [ ] Component rendered in parent (App.tsx or page)
- [ ] Command registered in invoke_handler
- [ ] End-to-end flow verified
- [ ] State machine transitions updated
**Priority:** HIGH
**Rationale:** 30% of stories had integration gaps found only in code review

### Action 2: Mandate Multi-Round Code Review for Security Stories

**Owner:** Scrum Master (Bob)
**Deadline:** Immediate (process change)
**Success Criteria:** Stories tagged "security" require minimum 2 code review rounds
**Priority:** HIGH
**Rationale:** Stories 2-7b and 2-9 needed 2 rounds; critical security bugs found in both

### Action 3: Create Retro Action Item Tracking Mechanism

**Owner:** Scrum Master (Bob)
**Deadline:** Before post-MVP epic starts
**Success Criteria:** Retro action items added to sprint-status.yaml with status field; reviewed at each standup
**Priority:** MEDIUM
**Rationale:** Only 1/5 Epic 1 action items completed; "assign and forget" pattern

---

## Significant Discoveries

### Discovery 1: No Architectural Assumptions Changed

**Finding:** Epic 2 execution validated all architecture decisions. ATTACH DATABASE migration, Argon2id parameters, SQLCipher integration, and OS keychain storage all worked as designed.

**Impact on Future Epics:** No changes needed to architecture document. Encryption foundation solid for post-MVP work.

### Discovery 2: Dev Agent Integration Gap Pattern Identified

**Finding:** Dev agents consistently build components/functions but don't verify end-to-end integration. 30% of stories had this gap. This is a systemic issue, not individual error.

**Impact on Future Epics:** Process change needed (Integration Verification Checklist) to prevent this pattern from recurring.

### Discovery 3: Recovery Key Re-Key Not Implemented (AC-6 Partial)

**Finding:** Story 2-9 AC-6 partially met — recovery key can unlock database but cannot re-key it with a new passphrase. This was documented and deferred due to SQLCipher re-key complexity.

**Impact on Future Epics:** This is a functional gap that should be addressed in post-MVP polish. Users who use recovery key cannot change their passphrase.

### Discovery 4: All MVP Epics Complete

**Finding:** With Epic 2's retrospective complete, all MVP epics (0, 1, 2, 3, 4a, 4b, 5, 6, 8) are done with retrospectives. The remaining epics (7, 9, 10) are post-MVP.

**Impact:** The project is at a natural milestone. Post-MVP planning should incorporate all lessons learned from MVP development.

---

## Readiness Assessment

### Testing & Quality: Adequate

**Status:** 194+ Rust tests, 245+ frontend tests passing. All stories code-reviewed. 6 pre-existing test failures in PreMigrationBackup.test.tsx.

**Gaps:**
- Backend Tauri command tests deferred (no test harness)
- Manual NFR validation done via code review, not measurement
- 6 pre-existing test failures need cleanup

**Confidence Level:** HIGH — Critical security functionality tested and reviewed. Gaps are defense-in-depth, not blocking.

### Deployment: N/A (Development Phase)

**Status:** No production deployment. Deployment is Epic 9 scope.

### Technical Health: Good with Caveats

**Status:** Encryption stack solid and working. OnceLock pattern architecturally clean. Migration flow end-to-end tested.

**Caveats:**
- Recovery key re-key not implemented (AC-6 partial)
- Memory zeroing and secure transport deferred
- Build environment requires platform-specific configuration

**Confidence Level:** HIGH — Security foundation meets all architecture requirements. Deferred items are enhancements.

### Unresolved Blockers: None

**Status:** All deferred items are enhancements, not blockers. No dependencies broken.

---

## Retrospective Commitments

### Summary

- **Action Items Created:** 3 process improvements
- **Technical Debt Documented:** 7 items (1 HIGH, 4 MEDIUM, 2 LOW)
- **Team Agreements:** 4
- **Critical Path Items:** 0 (no next epic in queue)

### Team Agreements

1. Every story must verify integration (component rendered, command invoked) before marking "review"
2. Security stories get mandatory 2-round code review
3. Task checkboxes must be updated as work progresses (no abandoned tracking)
4. Retro action items tracked in sprint-status with status updates

### Next Steps

1. **Review retrospective summary:** This document
2. **Address HIGH priority debt:** Recovery key re-key (Story 2-9 AC-6) before post-MVP
3. **Apply process changes:** Integration verification checklist, multi-round security review
4. **Plan post-MVP:** Epics 7 (History), 9 (Deployment), 10 (Dynamic Config) when ready

---

## Team Acknowledgments

Epic 2 delivered **10 stories with 100% completion and zero security vulnerabilities shipped**. The team demonstrated:

- **Security-first engineering** — Complete encryption stack with defense-in-depth
- **Architectural innovation** — OnceLock pattern improved on original design
- **Relentless code review** — Every critical bug caught before merge
- **Debt resolution** — Log level initialization deferred twice, finally resolved
- **Resilience** — Story 2-7 split handled gracefully with improved design

**Special Recognition:**
- Charlie (Senior Dev) for the OnceLock pattern innovation and thorough security implementation
- Dana (QA Engineer) for persistent code review quality across all 10 stories
- Elena (Junior Dev) for navigating the complex state refactoring across 53 commands
- Alice (Product Owner) for maintaining scope discipline during the 2-7 split

**Epic 2 Lessons Will Guide Post-MVP Development** — The patterns identified (integration verification, security review depth, retro accountability) are directly applicable to remaining epics and future projects.

---

**Retrospective Completed:** 2026-02-11
**Next Retrospective:** After next post-MVP epic
**Document:** epic-2-retro-2026-02-11.md
